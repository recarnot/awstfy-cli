const fs = require('fs');
const path = require('path');
const shell = require('shelljs');
const ini = require('ini');
const { renderString } = require('template-file')
const { getInfo } = require('../tools/helper');
const { getWorkspaceConfigPath, loadConfig } = require('../tools/config');
const { TFResoureTemplate } = require('../templates/template');
const TFVariable = require('../commands/var/variable');

class WorkspaceModel {
    constructor() {
    }

    workspaces = [];
    variables = {};
    _initialized = false;

    init() {
        try {
            var content = fs.readFileSync(getWorkspaceConfigPath(), { encoding: 'utf8' });
            var obj = JSON.parse(content);

            this.workspaces = obj.workspaces || [];
            this.variables = obj.variables || {};

            this._initialized = true;
            this.flush();
        }
        catch (err) {
            console.error(err);
        }
    }

    exist(name) {
        return this.workspaces.indexOf(name) > -1;
    }

    register(name) {
        if (!this.exist(name)) {
            this.workspaces.push(name);
            this.flush();
        }
    }


    addVariable(variable) {
        this.variables[variable.name] = variable;

        this.flush();
    }

    getVariable(name) {
        return this.variables[name];
    }

    getVariableValue(name, workspace) {
        if (!workspace) workspace = 'default';

        return this._workspace[workspace][name];
    }

    getVariableNames() {
        var list = [];
        for (const key in this.variables) {
            list.push(key);
        }
        list.sort();
        return list;
    }

    getChoices() {
        var questions = [];

        this.workspaces.forEach(element => {
            questions.push({
                type: 'input',
                name: `value_${element}`,
                message: `Enter the value in '${element}' workspace:`,
                when: function (answers) {
                    if (answers.overwrite == undefined) return true;
                    if (!answers.overwrite) return false;
                    return true;
                },
                validate: function (result) {
                    if (result.length < 1) {
                        return 'Must be set.'
                    }
                    return true
                }
            })
        });

        return questions;
    }

    updateVariable(variable) {
        var name = variable.name;
        if (this.variables.hasOwnProperty(name)) {
            this.variables[name] = variable;

            this.flush();
        }
    }

    deleteVariable(name) {
        if (this.variables.hasOwnProperty(name)) {
            delete this.variables[name];

            this.flush();
        }
    }

    clean(list) {
        var consolidate = this.workspaces.concat([]).filter(item => list.includes(item));
        var cleaner = this.workspaces.concat([]).filter(item => !list.includes(item));

        for (const key in this.variables) {
            cleaner.forEach(element => {
                delete this.variables[key]['values'][element];
                shell.rm(`env_${element}.tfvars`);
            });
        }

        this.workspaces = consolidate;
        this.flush();
    }

    flush() {
        this._fixEnv();
        this._save();
        this._export();
    }

    _fixEnv() {
        var env = TFVariable.create({
            name: 'environment',
            type: 'string',
            description: 'Current environment.',
            values: {}
        });

        this.workspaces.forEach(element => {
            env.values[element] = element;
        });

        this.variables[env.name] = env;
    }

    _save() {
        if (!this._initialized) return;

        var filename = getWorkspaceConfigPath();
        var content = JSON.stringify(this)
        fs.writeFileSync(filename, content);
    }

    _export() {
        this._exportTFVars();
        this._exportVariables();
    }

    _exportTFVars() {
        var filename = '';
        var current = {};

        this.workspaces.forEach(element => {
            filename = process.cwd() + `/env_${element}.tfvars`;

            if (!fs.existsSync(filename)) {
                fs.writeFileSync(filename, "");
            }

            current = ini.parse(fs.readFileSync(filename, 'utf-8'));

            for (const key in this.variables) {
                const variable = this.variables[key];

                if (variable.type === 'string') {
                    current[variable.name] = `"${variable.values[element]}"`;
                }
                else current[variable.name] = variable.values[element];
            }

            fs.writeFileSync(filename, ini.stringify(current));

        });
    }

    _exportVariables() {
        var content = `#Auto generated by ${getInfo().name}: ${getInfo().version}`;
        var newline = "\n";
        var filename = process.cwd() + '/env_variables.tf';
        var template_name = loadConfig('tf_version', '0.12') === '0.12' ? TFResoureTemplate.Variable_012 : TFResoureTemplate.Variable_013;
        var template_file = path.dirname(fs.realpathSync(__filename)) + "/../templates/" + template_name
        var template = shell.cat(template_file);
        var variable;

        for (const key in this.variables) {
            variable = this.variables[key];
            content += renderString(template, variable) + newline;
        }

        fs.writeFileSync(filename, content);
    }

    toString() {
        console.info(this.workspaces);
    }
}

const wsmodel = new WorkspaceModel();
exports.workspaceModel = wsmodel;